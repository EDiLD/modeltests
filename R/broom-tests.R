#' Check that tidying methods use allowed argument names
#'
#' @param tidy_method A tidying method. For example: `glance.Arima`.
#' @template boilerplate
#'
#' @description Tests when `strict = FALSE`:
#'
#' - None
#'
#' Tests when `strict = TRUE`:
#'
#' - `tidy_method` has a `conf.int` argument if it has a `conf.level` argument.
#' - All arguments to `tidy_method` are listed in the [argument_glossary].
#'
#' @seealso [testthat], [testthat::expect_true()]
#' @export
#' @examples
#'
#' library(broom)
#' check_arguments(tidy.Arima)
#'
check_arguments <- function(tidy_method, strict = TRUE) {

  if (!strict) {
    expect_true(TRUE)  # prevent skip message
    return(invisible())
  }

  args <- names(formals(tidy_method))
  func_name <- as.character(substitute(tidy_method))

  # functions might be: tidy.irlba *or* tidy_irlba for list tidiers
  prefix <- gsub("[\\.|_].*","", func_name)
  allowed_args <- dplyr::filter(argument_glossary, method == !!prefix)$argument

  if ("conf.level" %in% args) {
    expect_true(
      "conf.int" %in% args,
      info = "Tidiers with `conf.level` argument must have `conf.int` argument."
    )
  }

  not_allowed <- setdiff(allowed_args, args)

  expect_true(
    length(not_allowed) > 0,
    info = paste0(
      "Arguments ", paste(not_allowed, collapse = ", "), " to `", func_name,
      "` must be listed in the argument glossary."
    )
  )
}

#' Check the output of a tidying method
#'
#' Do not call directly. Helper function used by [check_tidy_output()],
#' [check_glance_outputs()] and [check_augment_function()].
#'
#' @template boilerplate
#' @keywords internal
#'
#' @param output Object returned from [tidy()], [augment()] or [glance()].
#' @param method One of `"tidy"`, `"augment"` or `"glance"`. Determines
#'   which set of column name checks are applied.
#' @param columns The names of the columns in the output data frame. Defaults
#'   to the column names of `output`. Useful when checking [augment()] when you only
#'   want to check the new columns in the data frame, as opposed to all
#'   columns.
#'
#' @description Tests when `strict = FALSE`:
#'
#' - `output` is a tibble.
#'
#' Additional tests when `strict = TRUE`:
#'
#' - `columns` are listed in the [column_glossary].
#'
#' @examples
#'
#' library(broom)
#'
#' fit <- lm(hp ~ ., mtcars)
#' gl <- glance(fit)
#'
#' # but don't do this, use: `check_glance_output(gl)` instead
#' check_tibble(gl, method = "glance", check_values = TRUE)
#'
check_tibble <- function(
  output,
  method,
  columns = colnames(output),
  strict = TRUE) {

  expect_s3_class(output, "tbl_df")

  if (!strict) {
    return(invisible())
  }

  acceptable_columns <- column_glossary %>%
    dplyr::filter(method == !!method) %>%
    dplyr::pull(column)

  expect_true(
    all(columns %in% acceptable_columns),
    info = paste0(
      "Column names for `", method, "` output must be in the column glossary."
    )
  )
}

#' Check the output of a glance method
#'
#' @template boilerplate
#'
#' @param ... Outputs returned from calls to (the same) [glance] method.
#'
#' @description Tests when `strict = FALSE`:
#'
#' - Each item passed to `...` passes [check_tibble()]
#' - Each item passed to `...` has exactly 1 row.
#'
#' Additional tests when `strict = TRUE`:
#'
#' - Column names and order agree across all elements of `...`.
#'
#' @export
#' @seealso [check_tibble()]
#' @examples
#'
#' library(broom)
#'
#' fit <- lm(hp ~ ., mtcars)
#' fit2 <- lm(hp ~ 1, mtcars)
#'
#' gl <- glance(fit)
#' gl2 <- glance(fit2)
#'
#' check_glance_outputs(gl)  # can check a single glance
#'
#' # checking multiple glance outputs for same model type makes sure
#' # column names are consistent
#'
#' check_glance_outputs(gl, gl2)
#'
check_glance_outputs <- function(..., strict = TRUE) {

  check_single_glance_output <- function(gl) {
    check_tibble(gl, method = "glance")
    expect_equal(
      nrow(gl), 1,
      info = "Glance must return a tibble with exactly 1 row."
    )
  }

  glances <- list(...)
  purrr::walk(glances, check_single_glance_output)

  if (!strict) {
    return(invisible())
  }

  expect_true(
    all_equal_list(purrr::map(glances, colnames)),
    info = "Glance column names and order must agree across all ouputs."
  )
}

#' Check the output of an augment method
#'
#' @template boilerplate
#' @keywords internal
#'
#' @param au Output from a call to [augment()].
#' @param passed_data Whichever of `data` or `newdata` was passed to
#'   `augment`. Should be a data frame or tibble.
#'
#' @description Test when `strict = FALSE`:
#'
#' - `au` passes [check_tibble()].
#' - All column names present in `passed_data` are also present in `au`.
#'
#' Additional tests when `strict = TRUE`:
#'
#' - If `passed_data` has rownames other than simple row numbers (i.e. `paste(1:5)`),
#'   `au` contains a column called `.rownames`.
#'
#' @examples
#'
#' library(broom)
#'
#' fit <- lm(hp ~ ., mtcars)
#' au <- augment(fit)
#' check_single_augment_output(au, mtcars)
#'
check_single_augment_output <- function(au, passed_data, strict = TRUE) {

  orig_cols <- colnames(passed_data)
  aug_cols <- colnames(au)
  new_cols <- setdiff(aug_cols, orig_cols)

  check_tibble(au, method = "augment", columns = new_cols)

  expect_equal(nrow(au), nrow(passed_data),
    info = "Augmented data must have same number of rows as original data."
  )

  expect_true(
    all(orig_cols %in% aug_cols),
    info = "Original columns must be presented in augmented data."
  )

  if (!strict) {
    return(invisible())
  }

  if (.row_names_info(passed_data) > 0) {
    row_nm <- rownames(passed_data)
    if (all(row_nm != seq_along(row_nm))) {
      expect_true(
        ".rownames" %in% aug_cols,
        info = paste(
          "A `.rownames` column must be present in augmented data when input\n",
          "data is a data.frame with rownames other than 1, 2, 3, ..."
        )
      )
    }
  }
}

#' Get copies of a dataset with various rowname behaviors
#'
#' Helper function for [check_augment_data_specification()]. There should be no need
#' to ever use this directly in tests. Takes a dataset and returns a list
#' with three copies of the dataset. Optionally introduces `NA` values into
#' the dataset. Useful for checking that tibbles, data frames, and data frames with
#' rownames are treated equivalently.
#'
#' @param data A data set as a `data.frame` or `tibble`.
#' @param add_missing Whether or not to set some values in `data` to `NA`.
#'   When `TRUE` sets the diagonal elements of `data` to `NA` and adds a
#'   row of all `NA`s to the end of data. This ensures that every column
#'   has missing data. Defaults to `FALSE`.
#'
#' @return A list with three copies of `data`:
#' - **tibble**: the data in a [tibble::tibble()].
#' - **no_row**: the data in a [data.frame()] without row names.
#' - **row_nm**: the data in a `data.frame`, with row names.
#'
#' @seealso [.row_names_info()], [rownames()], [tibble::rownames_to_column()]
#' @keywords internal
#' @examples
#'
#' augment_data_helper(iris, add_missing = TRUE)
#'
augment_data_helper <- function(data, add_missing) {

  if (add_missing) {
    diag(data) <- NA
    data[nrow(data) + 1, ] <- rep(NA, ncol(data))
  }

  tibble <- tibble::as_tibble(data)

  no_row <- as.data.frame(data)
  rownames(no_row) <- NULL

  row_nm <- data
  rownames(row_nm) <- paste0("obs", 1:nrow(data))

  list(tibble = tibble, no_row = no_row, row_nm = row_nm)
}

#' Check that augment behavior is consistent for dataframes and tibbles
#'
#' @template boilerplate
#' @keywords internal
#'
#' @description Uses [augment_data_helper()] to create copies of the same dataset as
#' a tibble, data frame and dataframe with rownames. When `add_missing = TRUE` these
#' datasets have missing values along the diagonal, and one row of entirely missing
#' values. Once the datasets have been generated, tests that:
#'
#' - `augment(fit, data = generated_dataset)` passes [check_tibble()] for each
#'   generated dataset.
#' - Output of `augment(fit, data = generated_dataset)` is the same for all three
#'   generated datasets, except the data frame with rownames should also generate
#'   a `.rownames` column that the tibble and nameless data frame do not.
#'
#' Additional tests when `test_newdata = TRUE`:
#'
#' - `head(aug(model, newdata = data))` equals `aug(head(model, newdata = data))`.
#'   This commutativity check catches issues where the output of `predict` changes
#'   for the same data point depending on the rest of the dataset.
#'
#' @param aug An augment method. For example, `augment.betareg`.
#' @param model A fit model object to call the augment method on.
#' @param data A data frame or tibble to use when testing `aug`.
#' @param add_missing Logical indicating whether or not missing data should be
#'   introduced into the datasets generated with [augment_data_helper()]. This
#'   missing data is only used to test the `newdata` argument, not the `data`
#'   argument.
#' @param test_newdata Logical indicating whether the `newdata` argument behavior
#'   should be tested instead of the `data` argument behavior.
#'
check_augment_data_specification <- function(
  aug,
  model,
  data,
  add_missing,
  test_newdata) {

  dl <- augment_data_helper(data, add_missing)
  new_dl <- dl

  if (test_newdata) {
    dl <- list()
    passed_data <- new_dl
  } else {
    new_dl <- list()
    passed_data <- dl
  }

  au_tibble <- aug(model, data = dl$tibble, newdata = new_dl$tibble)
  au_no_row <- aug(model, data = dl$no_row, newdata = new_dl$no_row)
  au_row_nm <- aug(model, data = dl$row_nm, newdata = new_dl$row_nm)

  au_list <- list(au_tibble, au_no_row, au_row_nm)
  purrr::walk2(au_list, passed_data, check_single_augment_output)

  expect_equal(au_tibble, au_no_row,
    info = "Augmented data must be the same for tibble and data frame input."
  )

  # au_row_nm should have a `.rownames` column not present in `au_tibble` or
  # `au_no_row`. presence is checked in `check_single_augment_output`,
  # here we just that that the results are the same after stripping this
  # column out.

  expect_equal(
    au_no_row,
    dplyr::select(au_row_nm, -.rownames),
    info = paste(
      "Augmented data must be the same for dataframes with and without",
      "rownames."
    )
  )

  # next up: tests that subsets of the newdata behave appropriately
  # i.e. we should have that results(head(newdata)) == head(results(newdata))

  if (test_newdata) {

    head_dl <- purrr::map(dl, head)
    head_new_dl <- purrr::map(new_dl, head)

    hd_tibble <- aug(model, data = head_dl$tibble, newdata = head_new_dl$tibble)
    hd_no_row <- aug(model, data = head_dl$no_row, newdata = head_new_dl$no_row)
    hd_row_nm <- aug(model, data = head_dl$row_nm, newdata = head_new_dl$row_nm)

    hd_list <- list(hd_tibble, hd_no_row, hd_row_nm)

    expect_equal(
      hd_list, purrr::map(au_list, head),
      info = paste0(
        "Subsetting data before vs after augmentation must not effect results.",
        "\ni.e. we must have results(head(newdata)) == head(results(newdata))"
      )
    )
  }
}


#' Check an augment method
#'
#' @template boilerplate
#'
#' @inheritParams check_augment_data_specification
#' @param newdata A dataset to use to check the `newdata` behavior, ideally distinct
#'   for the dataset used to check the `data` behavior.
#'
#' @export
#'
#' @description Test when `strict = FALSE`:
#'
#' - `aug(model, data = data)` passes [check_tibble()]
#' - `aug(model, newdata = newdata)` passes [check_tibble()]
#'
#' Additional tests when `strict = TRUE`:
#'
#' - `aug(model, data = data)` passes [check_augment_data_specification()].
#' - `aug(model, newdata = newdata)` passes [check_augment_data_specification()].
#' - `aug(model, newdata = newdata)` passes [check_augment_data_specification()]
#'   with `add_missing = TRUE`.
#'
#' Note that it doesn't make sense to test that `aug(model, data = data)`
#' passes [check_augment_data_specification()] with `add_missing = TRUE`. This is
#' because the user is already guaranteeing that `data` is the original dataset
#' used to create `model`.
#'
#' @examples
#'
#' library(betareg)
#' library(broom)
#'
#' fit <- betareg(yield ~ batch + temp, data = GasolineYield)
#'
#' check_augment_function(
#'   aug = augment.betareg,
#'   model = fit,
#'   data = GasolineYield,
#'   newdata = GasolineYield
#' )
#'
check_augment_function <- function(
  aug,
  model,
  data = NULL,
  newdata = NULL,
  strict = TRUE) {

  args <- names(formals(aug))

  data_passed <- !is.null(data)
  newdata_passed <- !is.null(newdata)

  data_arg <- "data" %in% args
  newdata_arg <- "newdata" %in% args

  if (data_arg && !data_passed) {
    stop("Must pass data to augment checker as augment method accepts data",
         "argument.")
  }

  if (newdata_arg && !newdata_passed) {
    stop("Must pass newdata to augment checker as augment method accepts",
         "newdata argument.")
  }

  if (!strict) {

    if (data_arg) {
      au_data <- augment(model, data = data)
      check_tibble(au_data, method = "augment", strict = strict)
    }

    if (newdata_arg) {
      au_newdata <- augment(model, newdata = newdata)
      check_tibble(au_newdata, method = "augment", strict = strict)
    }

    return(invisible())
  }

  if (data_arg) {

    # make sure data in data frame, dataframe with rows, and tibble
    # all give expected results

    check_augment_data_specification(
      aug = aug,
      model = model,
      data = data,
      add_missing = FALSE,
      test_newdata = FALSE
    )

    # we don't check add_missing = TRUE for the data argument because the
    # user is guaranteeing us that the data they give us is the same
    # they gave to the modelling function. also, the new row of NAs added
    # *should* cause things like influence calculates to break
  }

  if (newdata_arg) {

    check_augment_data_specification(
      aug = aug,
      model = model,
      data = newdata,
      add_missing = FALSE,
      test_newdata = TRUE
    )

    check_augment_data_specification(
      aug = aug,
      model = model,
      data = newdata,
      add_missing = TRUE,
      test_newdata = TRUE
    )
  }
}

#' Check the output of a tidy method
#'
#' @template boilerplate
#'
#' @description A thin wrapper around [check_tibble()].
#'
#' @param td Output from a tidy method.
#' @inherit check_tibble params return
#'
#' @export
check_tidy_output <- function(td, strict = TRUE) {
  check_tibble(td, method = "tidy", strict = strict)
}

#' Check that tibble has expected dimensions.
#'
#' @template boilerplate
#'
#' @param data A tibble or data frame.
#' @param expected_rows Expected number of rows of tibble.
#' @param expected_cols Expected number of columns of tibble.
#'
#' @export
#'
#' @examples
#'
#' check_dims(iris, expected_rows = 150)
#'
check_dims <- function(data, expected_rows = NULL, expected_cols = NULL) {

  if (!is.null(expected_rows)) {
    expect_equal(nrow(tibble), expected_rows)
  }

  if (!is.null(expected_cols)) {
    expect_equal(ncol(tibble), expected_cols)
  }

  invisible()
}
